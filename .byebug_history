c
response.body
c
response.body
response
response.parsed_response
c
response.parsed_response
response.code
response
response.parsed_response
c
params
projects
c
Project.all
projects
c
JSON.parse(result[:result])
JSON
JSON.pase(result[:result])
JSON.pase result[:result]
result[:result]
result
c
json
json["repositories"]
c
json
c
json
c
json
c
json[0]
BoardSerializer.new(board).as_json
BoardSerializer.new(board)
json
c
board
json
c
Board.all
c
Board.all
policy_scope(Board)
c
Board.all
board
json
c
json
c
json
response
c
results
c
repositories_assigned
c
repositories_assigned
c
results[:result].find { |repository| repository["id"] == ids_to_update[0].to_i }
ids_to_update
results[:result].pluck("id")
results[:result]
results[:result].find { |repository| repository["id"] == ids_to_update[0] }
esults[:result].find { |repository| repository["id"] == ids_to_update[0] }
ids_to_update
c
existing_ids
response_ids
c
ids_to_create
new_id_repository
results[:result][0]
results[:result]
results
c
params.keys
params
c
"#{ENV['GITHUB_URL']}/user/repos#{query_params}"
results.code
results
c
exit
c
puts caller.join("\n")
c
puts caller.join("\n")
c
caller
c
caller
request
c
params
c
response.code == 200 && !response.parsed_response.include?("error")
response.parsed_response.include?("error")
response.parsed_response
response.body
response.code
response
c
response.parsed_response
response.body
response.request
response.response
body_params
response
c
"#{ENV['GITHUB_URL']}/login/oauth/access_token"
response.response
response.json
response.code
body_params
response
continue
c
params
c
current_user
params
c
params
c
service = Tasks::UpdateStates.new(@task, task_params[:event]).call
@task.may_complete?
@task.may_to_start?
@task.class
@task.klass
@task
task_params[:event].to_sym
task_params[:event]
c
Task.last.send("#{event}!")
task
task.send("#{event}!")
task.send("may_#{event}?")
event == "to_start"
event
c
task.send("may_#{@params[:event]}?")
c
task.start
task.complete
task.start
task.send(@params[:event].to_sym)
@params[:event].to_sym
task.send("may_#{@params[:event]}?")
c
task.send("may_#{@params[:event]}?")
task.may_start?
task.may_todo?
Task.aasm.states_for_select
task.aasm.states.map(&:name)
task.may_send
task.todo?
task
@params[:event].to_sym
task.may_send?(@params[:event].to_sym)
c
reload!
task.status
task.in_progress?
task.todo?
task
task.may_send?(@params[:event].to_sym)
@params[:event]
c
User.last
new_user_ids.each { |id| task.user_tasks.create!(user_id: id) }
task.user_tasks.last
new_user_ids.each { |id| task.user_tasks.create(user_id: id) }
task.user_tasks.last
task.user_tasks-
task.user_tasks
new_user_ids = user_ids - existing_user_ids
user_ids
existing_user_ids
c
@params
c
task = Task.create(task_params)
task.user_tasks
c
cc
c
params.permit(:title, :description, :status, :due_date, :board_id, users_assigned: [])
params
params[:task]
params
task_params
exit
@params
params
user_ids
task_params
c
UserSerializer.new(users)
users.size
users = policy_scope(User)
policy_scope(User)
c
request
request.env['HTTP_AUTHORIZATION'].try(:split, " ").try(:second) || request.params[:http_authorization]
equest.env['HTTP_AUTHORIZATION'].try(:split, " ").try(:second) || request.params[:http_authorization]
get_token
jwt_authenticate!
continue
